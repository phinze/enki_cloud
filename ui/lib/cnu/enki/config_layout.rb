
require 'pathname'

require 'etc'
require 'fileutils'

include FileUtils

module CNU::Enki::ConfigLayout

def output_fn(prefix, suffix)
  if File.directory?(prefix) then
    File.join(prefix,suffix)
  else
    "#{prefix}.#{suffix}"
  end
end


def layout_items_with_timing(label, items, &block)
    t = Time.now()
    total = 0
    cnt = 0
    items.each { |n|
      begin
       x = yield n
       if x then
         cnt = cnt + 1
       end
       total = total + 1
      rescue Object =>e
        puts e
	puts e.backtrace if $VERBOSE
      end
    }
    puts "Creating #{label} #{cnt}/#{total}" if $VERBOSE
    print_runtime(t, label)
end

def format_bash_array(data)
    data.map{|a| %Q(\t"#{a.join(':')}") }.sort.uniq.join("\n")
end

def mkdir(d)
  begin
    Dir.mkdir(d)
  rescue Object =>e
    puts e
  end
end

def version_string(opts={})
  fn = Pathname.new($0).basename 
  if opts.key?(:no_comment) and opts[:no_comment] 
    prefix = ''
  else
    prefix = "########  "
  end
  "#{prefix}autogenerated from cnu it cfg db"
end

def reset_git_repo
  %x{git reset HEAD .}
  %x{git checkout  .}
end

def git_commit_pending_changes(fn)
  %Q{git commit -F `pwd`/#{fn}  -s }
end
def find_deleted_files
  find_deleted = "git-ls-files -d ."
  `#{find_deleted}`.split(/\n/).map{|a| %Q("#{a.split().last}") }
end

def deleted_files_cmd(suffix='')
  deleted = find_deleted_files()
  if deleted.length > 0 then
    delete_files_cmd = "git rm #{deleted.join(' ')} #{suffix}"
  else
    delete_files_cmd = ''
  end 
  return delete_files_cmd 
end

# def print_git_commands(dirs)
#   %Q{#!/bin/sh
# # need version and time stamp
# git add #{dirs.join(' ')}
# #{deleted_files_cmd()}
# # commit and sign
# git commit -F `pwd`/.new.commit.log  -s 
# }
# end

def commit_files(dirs, options={:dry_run => false, :files=>[]}) 
  dry_run = options[:dry_run] 
  files = options[:files] 
  msg = write_commit_message()
  cmd = %Q{
        git add #{dirs.join(' ')} #{files.join(' ')}&& \\
        #{deleted_files_cmd('&&')} \\
        #{git_commit_pending_changes(msg)}
  }
  if dry_run then
    cmd
  else
    %x{#{cmd}}
  end
end
def write_commit_message(opts={:user=>nil})
  deleted = find_deleted_files
  fn = '.new.commit.log'
  File.open(fn, 'w') do  |io|
    io.puts "#{version_string(:no_comment=>true )} on #{now()}"
    u = select_user_name(opts[:user])
    io.puts "by user #{u}"
    if deleted.length > 0 then
      io.puts "Deleted configs:"
      io.puts deleted.join("\n")
    end
  end
  return fn
end

def select_user_name(possible_username)
  possible_username = '' if possible_username.nil?
  u = Etc.getpwuid().name
  sudo_user = ENV['SUDO_USER'] || nil
  env_user=ENV["USER"]

  return sudo_user unless sudo_user.nil? 
  if ['root','cnuit'].member? u  then 
    if possible_username.nil? or possible_username.strip() == ''  then
      return 'web app' 
    else
     return possible_username
    end
  end 
  return u
end
def color(c, v)

end
def print_runtime(start_time, message='')
  n = Time.now()
  puts "Runtime: #{message.ljust(55,' ')} #{(n - start_time)}s"
end
def create_node_structure(prefix)
    nodes = Node.find_all_active
    nodes.each { |n|
        d = File.join(prefix, n.fn_prefix) 
        mkdir(d)
    }
end
def create_dir(dirs)
  dirs.each { |d| mkdir(d) }
  File.open( '.dirs','w') {|io|
      io.puts dirs.join("\n")
  }
end
def ruby(cmd)
    t = now(false)
    require cmd
    print_runtime(t,cmd) 
end
def move_match(fn, glob)
    Dir.glob("node/#{glob}") { |dir|
      cp(fn, dir)
    }
    rm(fn)
end
def check_ldirectord(fileglob, check_script) 
    puts "Checking ldirectord files..."
    t = now(false)
    Dir.glob(fileglob) { |fn|
      x = `#{check_script} #{fn} status`
      unless $? == 0  then
        puts "ERROR: #{fn}: #{x} #{$?}" 
        # rm(fn)
      end
      unless x.strip() == ''
        puts "ERROR: #{fn}"
        rm(fn)
      end
    }
    print_runtime(t)
end

def now(rc_string=true)
  if rc_string then
    DateTime.now().strftime('%h %d, %Y %H:%M:%S')
  else
    Time.now()
  end
end

def generate_md5sums(fn, dirs)
  t = Time.now()
  %x(md5deep -z -l -r #{dirs.sort.join(' ')} > #{fn})
  print_runtime(t,'md5 checksums')
end

# FIXME: enova facts
def domain_name
  "example.com"
end

#
# FIXME: enova facts
#
def dns_header(domain, serial=nil)
  "
;####################################################################
;########       THIS FILE WAS AUTOMATICALLY GENERATED     ###########
;####################################################################
;# 
; #{version_string()}
;#
;# 
$TTL 8h
$ORIGIN #{domain}
@                       IN SOA  nsmaster.#{domain_name}. hostmaster.#{domain_name}. (
                                %SERIAL%        ; serial
                                7200            ; refresh (2 hours)
                                900             ; retry (15 minutes)
                                691200          ; expire (1 week 1 day)
                                7200            ; minimum (2 hours)
                                )
                        IN      NS      ns01.nut.#{domain_name}.
                        IN      NS      ns01.chi.#{domain_name}.
                        IN      NS      ns02.nut.#{domain_name}.
                        IN      NS      ns02.chi.#{domain_name}.

  "
end

def write_dns_file(fn, data, domain, serial=nil)
 # full_domain = domain.to_s + '.'  unless domain =~ /\.$/ || domain == '@'
  File.open( fn,'w') {|io|
      io.puts dns_header(domain, serial)
      io.puts data.join("\n")
  }
end

#
# lockfiles
#

def lockfile_start()
  lockfile(true)
end

private 
def lockfile_finish()
  lockfile(false)
end

def lockfile(create)
  lock_fn='.lock'
  if create then 
    begin
      File.open(lock_fn, File::WRONLY| File::CREAT| File::EXCL) { |io| io.puts $$ }
      at_exit { lockfile_finish() }
    rescue Object => e
      puts "Fail: Process running. #{lock_fn}: #{e.to_str}"
      exit(-5)
    end
  else
    require 'fileutils'
    FileUtils.rm_f(lock_fn)
  end
end

#
# use actionview/controller to create files 
#
# these need to be moved to a new file

def get_url_dir_output(urlpath, base, directory, filename)
    get_url_output(urlpath, base, File.join(directory, filename) )
end 

def get_url_output(urlpath, base, output )
    get_url("#{urlpath}/#{base}", output)
end

# 'console_app' required here to prevent unit tests from breaking
def get_url(url, filename)
    require "console_app"
    app.get(url) 
    File.open(filename,'w') do |io|
      io.puts app.html_document.root.to_s
    end
end


end 
__END__
